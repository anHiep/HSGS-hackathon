const { WritableStream } = typeof window !== "undefined"
    ? window
    : typeof global !== "undefined"
        ? global
        : globalThis;

const PolyfillWebSocket = WebSocket ?? global?.WebSocket ?? window?.WebSocket ?? self?.WebSocket;
const factory = (url, params) => {
    if (params) {
        return new PolyfillWebSocket(url, params);
    }
    return new PolyfillWebSocket(url);
};

var RealtimeErrorType;
(function (RealtimeErrorType) {
    RealtimeErrorType[RealtimeErrorType["BadSampleRate"] = 4000] = "BadSampleRate";
    RealtimeErrorType[RealtimeErrorType["AuthFailed"] = 4001] = "AuthFailed";
    // Both InsufficientFunds and FreeAccount error use 4002
    RealtimeErrorType[RealtimeErrorType["InsufficientFundsOrFreeAccount"] = 4002] = "InsufficientFundsOrFreeAccount";
    RealtimeErrorType[RealtimeErrorType["NonexistentSessionId"] = 4004] = "NonexistentSessionId";
    RealtimeErrorType[RealtimeErrorType["SessionExpired"] = 4008] = "SessionExpired";
    RealtimeErrorType[RealtimeErrorType["ClosedSession"] = 4010] = "ClosedSession";
    RealtimeErrorType[RealtimeErrorType["RateLimited"] = 4029] = "RateLimited";
    RealtimeErrorType[RealtimeErrorType["UniqueSessionViolation"] = 4030] = "UniqueSessionViolation";
    RealtimeErrorType[RealtimeErrorType["SessionTimeout"] = 4031] = "SessionTimeout";
    RealtimeErrorType[RealtimeErrorType["AudioTooShort"] = 4032] = "AudioTooShort";
    RealtimeErrorType[RealtimeErrorType["AudioTooLong"] = 4033] = "AudioTooLong";
    RealtimeErrorType[RealtimeErrorType["BadJson"] = 4100] = "BadJson";
    RealtimeErrorType[RealtimeErrorType["BadSchema"] = 4101] = "BadSchema";
    RealtimeErrorType[RealtimeErrorType["TooManyStreams"] = 4102] = "TooManyStreams";
    RealtimeErrorType[RealtimeErrorType["Reconnected"] = 4103] = "Reconnected";
    RealtimeErrorType[RealtimeErrorType["ReconnectAttemptsExhausted"] = 1013] = "ReconnectAttemptsExhausted";
})(RealtimeErrorType || (RealtimeErrorType = {}));
const RealtimeErrorMessages = {
    [RealtimeErrorType.BadSampleRate]: "Sample rate must be a positive integer",
    [RealtimeErrorType.AuthFailed]: "Not Authorized",
    [RealtimeErrorType.InsufficientFundsOrFreeAccount]: "Insufficient funds or you are using a free account. This feature is paid-only and requires you to add a credit card. Please visit https://assemblyai.com/dashboard/ to add a credit card to your account.",
    [RealtimeErrorType.NonexistentSessionId]: "Session ID does not exist",
    [RealtimeErrorType.SessionExpired]: "Session has expired",
    [RealtimeErrorType.ClosedSession]: "Session is closed",
    [RealtimeErrorType.RateLimited]: "Rate limited",
    [RealtimeErrorType.UniqueSessionViolation]: "Unique session violation",
    [RealtimeErrorType.SessionTimeout]: "Session Timeout",
    [RealtimeErrorType.AudioTooShort]: "Audio too short",
    [RealtimeErrorType.AudioTooLong]: "Audio too long",
    [RealtimeErrorType.BadJson]: "Bad JSON",
    [RealtimeErrorType.BadSchema]: "Bad schema",
    [RealtimeErrorType.TooManyStreams]: "Too many streams",
    [RealtimeErrorType.Reconnected]: "Reconnected",
    [RealtimeErrorType.ReconnectAttemptsExhausted]: "Reconnect attempts exhausted",
};
class RealtimeError extends Error {
}

const defaultRealtimeUrl = "wss://api.assemblyai.com/v2/realtime/ws";
const forceEndOfUtteranceMessage = `{"force_end_utterance":true}`;
const terminateSessionMessage = `{"terminate_session":true}`;
class RealtimeTranscriber {
    constructor(params) {
        this.listeners = {};
        this.realtimeUrl = params.realtimeUrl ?? defaultRealtimeUrl;
        this.sampleRate = params.sampleRate ?? 16_000;
        this.wordBoost = params.wordBoost;
        this.encoding = params.encoding;
        this.endUtteranceSilenceThreshold = params.endUtteranceSilenceThreshold;
        this.disablePartialTranscripts = params.disablePartialTranscripts;
        if ("token" in params && params.token)
            this.token = params.token;
        if ("apiKey" in params && params.apiKey)
            this.apiKey = params.apiKey;
        if (!(this.token || this.apiKey)) {
            throw new Error("API key or temporary token is required.");
        }
    }
    connectionUrl() {
        const url = new URL(this.realtimeUrl);
        if (url.protocol !== "wss:") {
            throw new Error("Invalid protocol, must be wss");
        }
        const searchParams = new URLSearchParams();
        if (this.token) {
            searchParams.set("token", this.token);
        }
        searchParams.set("sample_rate", this.sampleRate.toString());
        if (this.wordBoost && this.wordBoost.length > 0) {
            searchParams.set("word_boost", JSON.stringify(this.wordBoost));
        }
        if (this.encoding) {
            searchParams.set("encoding", this.encoding);
        }
        searchParams.set("enable_extra_session_information", "true");
        if (this.disablePartialTranscripts) {
            searchParams.set("disable_partial_transcripts", this.disablePartialTranscripts.toString());
        }
        url.search = searchParams.toString();
        return url;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    on(event, listener) {
        this.listeners[event] = listener;
    }
    connect() {
        return new Promise((resolve) => {
            if (this.socket) {
                throw new Error("Already connected");
            }
            const url = this.connectionUrl();
            if (this.token) {
                this.socket = factory(url.toString());
            }
            else {
                this.socket = factory(url.toString(), {
                    headers: { Authorization: this.apiKey },
                });
            }
            this.socket.binaryType = "arraybuffer";
            this.socket.onopen = () => {
                if (this.endUtteranceSilenceThreshold === undefined ||
                    this.endUtteranceSilenceThreshold === null) {
                    return;
                }
                this.configureEndUtteranceSilenceThreshold(this.endUtteranceSilenceThreshold);
            };
            this.socket.onclose = ({ code, reason }) => {
                if (!reason) {
                    if (code in RealtimeErrorType) {
                        reason = RealtimeErrorMessages[code];
                    }
                }
                this.listeners.close?.(code, reason);
            };
            this.socket.onerror = (event) => {
                if (event.error)
                    this.listeners.error?.(event.error);
                else
                    this.listeners.error?.(new Error(event.message));
            };
            this.socket.onmessage = ({ data }) => {
                const message = JSON.parse(data.toString());
                if ("error" in message) {
                    this.listeners.error?.(new RealtimeError(message.error));
                    return;
                }
                switch (message.message_type) {
                    case "SessionBegins": {
                        const openObject = {
                            sessionId: message.session_id,
                            expiresAt: new Date(message.expires_at),
                        };
                        resolve(openObject);
                        this.listeners.open?.(openObject);
                        break;
                    }
                    case "PartialTranscript": {
                        // message.created is actually a string when coming from the socket
                        message.created = new Date(message.created);
                        this.listeners.transcript?.(message);
                        this.listeners["transcript.partial"]?.(message);
                        break;
                    }
                    case "FinalTranscript": {
                        // message.created is actually a string when coming from the socket
                        message.created = new Date(message.created);
                        this.listeners.transcript?.(message);
                        this.listeners["transcript.final"]?.(message);
                        break;
                    }
                    case "SessionInformation": {
                        this.listeners.session_information?.(message);
                        break;
                    }
                    case "SessionTerminated": {
                        this.sessionTerminatedResolve?.();
                        break;
                    }
                }
            };
        });
    }
    sendAudio(audio) {
        this.send(audio);
    }
    stream() {
        return new WritableStream({
            write: (chunk) => {
                this.sendAudio(chunk);
            },
        });
    }
    /**
     * Manually end an utterance
     */
    forceEndUtterance() {
        this.send(forceEndOfUtteranceMessage);
    }
    /**
     * Configure the threshold for how long to wait before ending an utterance. Default is 700ms.
     * @param threshold - The duration of the end utterance silence threshold in milliseconds.
     * This value must be an integer between 0 and 20_000.
     */
    configureEndUtteranceSilenceThreshold(threshold) {
        this.send(`{"end_utterance_silence_threshold":${threshold}}`);
    }
    send(data) {
        if (!this.socket || this.socket.readyState !== this.socket.OPEN) {
            throw new Error("Socket is not open for communication");
        }
        this.socket.send(data);
    }
    async close(waitForSessionTermination = true) {
        if (this.socket) {
            if (this.socket.readyState === this.socket.OPEN) {
                if (waitForSessionTermination) {
                    const sessionTerminatedPromise = new Promise((resolve) => {
                        this.sessionTerminatedResolve = resolve;
                    });
                    this.socket.send(terminateSessionMessage);
                    await sessionTerminatedPromise;
                }
                else {
                    this.socket.send(terminateSessionMessage);
                }
            }
            if (this.socket?.removeAllListeners)
                this.socket.removeAllListeners();
            this.socket.close();
        }
        this.listeners = {};
        this.socket = undefined;
    }
}
/**
 * @deprecated Use RealtimeTranscriber instead
 */
class RealtimeService extends RealtimeTranscriber {
}

export { RealtimeService, RealtimeTranscriber };
